<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Recursion | Prab's Code Blog]]></title>
  <link href="http://prabhakar97.github.io/blog/categories/recursion/atom.xml" rel="self"/>
  <link href="http://prabhakar97.github.io/"/>
  <updated>2018-03-29T20:44:09+05:30</updated>
  <id>http://prabhakar97.github.io/</id>
  <author>
    <name><![CDATA[Prabhakar Kumar]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Functional Programming Series - Part 1]]></title>
    <link href="http://prabhakar97.github.io/blog/2016/05/13/getting-started-with-haskell/"/>
    <updated>2016-05-13T20:02:00+05:30</updated>
    <id>http://prabhakar97.github.io/blog/2016/05/13/getting-started-with-haskell</id>
    <content type="html"><![CDATA[<p>I have been intrigued by functional programming for past couple of years, but never quite prioritized it bigtime. Recently I came across this amazing talk which inspired me
to go all-in to learn FP.</p>

<p><div class="embed-video-container"><iframe src="//www.youtube.com/embed/E8I19uA-wGY" allowfullscreen></iframe></div></p>

<p>I chose Haskell as my preferred language and started with the book <a href="http://www.amazon.com/dp/0954300696">The Haskell Road to Logic, Maths and Programming</a>. The reason was
primarily because this book induces functional thinking without being too theoretical.</p>

<p>I started solving exercises from the book. This post and a few subsequent ones will document my solutions to some of the exercise problems. These solutions may not be most concise
or efficient because I am just beginning to learn Haskell.</p>

<blockquote><p>Define a method removeFst which removes the first instance of an element from a list</p></blockquote>

<pre><code class="hs removeFst.hs">removeFst :: (Eq a) =&gt; [a] -&gt; a -&gt; [a]
removeFst (x:xs) y = if x == y
                        then xs
                        else x : removeFst xs y
</code></pre>

<blockquote><p>Define a function which counts number of instances of an element in a list</p></blockquote>

<pre><code class="hs countChars.hs">countChars :: Char -&gt; String -&gt; Int
countChars y [] = 0
countChars y (x:xs) | y == x = 1 + countChars y xs
                    | otherwise = countChars y xs
</code></pre>

<blockquote><p>Define a function named blowUp that takes an string and creates a new string from it by repeating ith character in i times. For example: abcdef should return abbcccddddeeeeeffffff</p></blockquote>

<pre><code class="hs blowUp.hs">blowUp :: Int -&gt; String -&gt; String
blowUp n [x] = take n [x,x..]
blowUp n (x:xs) = (blowUp n [x]) ++ (blowUp (n+1) xs)
</code></pre>

<blockquote><p>Write a function to sort a list of orderable elements</p></blockquote>

<p>This is a translation of the famous quick sort algorithm to Haskell.</p>

<pre><code class="hs sort.hs">sort :: (Ord a) =&gt; [a] -&gt; [a]
sort [] = []
sort [x] = [x]
sort (x:xs) = sort greater ++ [x] ++ sort lesser
                where greater = [y | y &lt;- xs, y &gt; x]
                      lesser = [y | y &lt;- xs, y &lt; x ]
</code></pre>

<blockquote><p>Write a function that takes a big string and a small string and tells whether the big string starts with the small string</p></blockquote>

<pre><code class="hs startWith.hs">startWith :: String -&gt; String -&gt; Bool
startWith (x:xs) [y] = y == x
startWith (x:xs) (y:ys) = y == x &amp;&amp; startWith xs ys
</code></pre>

<blockquote><p>Write a function that takes a big string and a small string and tells whether the big string contains the small string as a substring</p></blockquote>

<p>I use the previously defined startWith function to solve this.</p>

<pre><code class="hs substring.hs">contains :: String -&gt; String -&gt; Bool
contains (x:xs) [] = True
contains (x:xs) y = startWith (x:xs) y || startWith xs y
</code></pre>
]]></content>
  </entry>
  
</feed>
